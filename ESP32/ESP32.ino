/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/3077899e-58d7-4098-bfbf-de7921b99cd0 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float dist;
  float t;
  CloudSwitch bedroomLights;
  CloudSwitch door;
  CloudSwitch motion;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/
#include "thingProperties.h"

// distance buzzer 
#include "pitches.h"
const int BUZZZER_PIN = 21; // GIOP18 pin connected to piezo buzzer
const int PIN_TO_SENSOR = 22; // GPIO19 pin connected to OUTPUT pin of sensor
#define SS_PIN 5
#define RST_PIN 0
#include <SPI.h>
#include <MFRC522.h>
MFRC522 rfid(SS_PIN, RST_PIN); // Create instance of MFRC522
#define BUZZER 16
//int pinStateCurrent   = LOW;  // current state of pin
// notes in the melody:
int melody[] = {
  NOTE_E5, NOTE_E5, NOTE_E5,
  NOTE_E5, NOTE_E5, NOTE_E5,
  NOTE_E5, NOTE_G5, NOTE_C5, NOTE_D5,
  NOTE_E5,
  NOTE_F5, NOTE_F5, NOTE_F5, NOTE_F5,
  NOTE_F5, NOTE_E5, NOTE_E5, NOTE_E5, NOTE_E5,
  NOTE_E5, NOTE_D5, NOTE_D5, NOTE_E5,
  NOTE_D5, NOTE_G5
};

// note durations: 4 = quarter note, 8 = eighth note, etc, also called tempo:
int noteDurations[] = {
  8, 8, 4,
  8, 8, 4,
  8, 8, 8, 8,
  2,
  8, 8, 8, 8,
  8, 8, 8, 16, 16,
  8, 8, 8, 8,
  4, 4
};

int motor1Pin1 = 27; 
int motor1Pin2 = 26; 
int light1 = 25;

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  pinMode(motor1Pin1, OUTPUT);
  pinMode(motor1Pin2, OUTPUT);
  pinMode(PIN_TO_SENSOR, INPUT);
  pinMode(light1, OUTPUT);
  SPI.begin(); // Initialize SPI bus
  rfid.PCD_Init(); // Initialize RFID module
  pinMode(BUZZER, OUTPUT);
  noTone(BUZZER);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  ArduinoCloud.update();
  // Your code here 
  motion = digitalRead(PIN_TO_SENSOR);   //read new state
  if (rfid.PICC_IsNewCardPresent() && rfid.PICC_ReadCardSerial()) {
    // Read card UID
    String cardUID = "";
    for (byte i = 0; i < rfid.uid.size; i++) {
      cardUID += String(rfid.uid.uidByte[i] < 0x10 ? "0" : "");
      cardUID += String(rfid.uid.uidByte[i], HEX);
    }
    cardUID.toUpperCase();

    Serial.println("RFID Tag detected: " + cardUID);

    if (cardUID.equals("C2AE046B")) {
      // C2AE046B for the blue tag
      //Serial.println("Access granted!");
      door= HIGH;
      tone(BUZZER, 500);
      delay(300);
      noTone(BUZZER);
    } else {
      //Serial.println("Access denied!");
      door= LOW;
      tone(BUZZER, 300);
      delay(1000);
      noTone(BUZZER);
    }

    rfid.PICC_HaltA(); // Halt the current tag
    rfid.PCD_StopCrypto1(); // Stop encryption on PCD
  

  
}
}

/*
  Since T is READ_WRITE variable, onTChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTChange()  {
  // Add your code here to act upon T change
  if(t>25){
    digitalWrite(motor1Pin1, LOW);
    digitalWrite(motor1Pin2, HIGH); 
  }
  else{
    digitalWrite(motor1Pin1, LOW);
    digitalWrite(motor1Pin2, LOW);
}
  
}

/*
  Since Dist is READ_WRITE variable, onDistChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onDistChange()  {
  if(dist<6)
  {
    int size = sizeof(noteDurations) / sizeof(int);
  
    for (int thisNote = 0; thisNote < size; thisNote++) {
  
      // to calculate the note duration, take one second divided by the note type.
      //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.
      int noteDuration = 1000 / noteDurations[thisNote];
      tone(BUZZZER_PIN, melody[thisNote], noteDuration);
  
      // to distinguish the notes, set a minimum time between them.
      // the note's duration + 30% seems to work well:
      int pauseBetweenNotes = noteDuration * 1.30;
      delay(pauseBetweenNotes);
      // stop the tone playing:
      noTone(BUZZZER_PIN);
    }
  }
}


/*
  Since BedroomLights is READ_WRITE variable, onBedroomLightsChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onBedroomLightsChange()  {
  // Add your code here to act upon BedroomLights change
  digitalWrite(light1, bedroomLights);
}


